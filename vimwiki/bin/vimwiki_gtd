#!/usr/bin/env python3

# Usage:
# vimwiki_gtd path_to_projects.md
# Returns a JSON version of the file passed to it, for use by other tools

import os, sys
from pathlib import Path
import json
import re

path_to_projects = Path(sys.argv[1])
projects_text = path_to_projects.read_text()
projects_text_lines = projects_text.split('\n')

# Our regular expressions
# Projects - start with a header #
project_match = r'^# .*'
# Sub-project - start with a header (multiple) ##
sub_project_match = r'^#{2,}'
# Task (open)
task_open_match = r'^\s*- \[[^X]\]'
# Task (done)
task_done_match = r'^\s*- \[X\]'
# plh-evil: also do partially-done tasks "- [O]"

    # if re.search(project_match, line):
    #     add_project(line)
    # elif re.search(sub_project_match, line):
    #     add_project(line)
    # elif re.search(task_open_match, line):
    #     add_task(line)
    # elif re.search(task_done_match, line):
    #     add_task(line)
    # else:
    #     add_note(line)


# Tasks are:
# - text: String
# - done: Boolean
# - children: [Task]
# - tags: [String]
task_template = { 'text' : '', 'done': False, 'children': [], 'tags': [], 'line_number': -1 }

# Projects are:
# - name: String
# - children: [Project]
# - tasks: [Task]
project_template = { 'name' : '', 'tasks': [], 'line_number': -1 ,'children' : [] }

out = { }

# Returns the depth of a particular line
def line_depth(line, prefix):
    if line.startswith(prefix):
        return 1 + line_depth(line.removeprefix(prefix), prefix)
    return 0

def lines_into_project(lines, depth):
    project = project_template.copy()

    for line in lines:
        text = line['text']
        # If we find a sub-project, bail - we don't have more to do here
        if text.startswith('# '):
            break
    return project

# Takes an array of line dictionaries and returns an array of projects
def lines_into_projects(all_lines, lines, depth=0):
    projects = [ ]
    # Find all the project line numbers. We'll use these to parse ranges of
    # lines into projects
    project_line_numbers = [ ]
    prefix = "#" * (depth+1) + ' '
    for line in lines:
        if line['text'].startswith(prefix):
            project_line_numbers.append(line['line_number'])

    # Now, take the numbers and parse each range into a project with children
    for line_number_index in range(0, len(project_line_numbers)):
        line_number_start = project_line_numbers[line_number_index]
        line_number_end = len(lines)-1
        if line_number_index < len(project_line_numbers)-1:
            line_number_end = project_line_numbers[line_number_index+1]

        project_lines = all_lines[line_number_start:line_number_end]
        project = lines_into_project(project_lines, depth)
        project['name'] = all_lines[line_number_start]['text'].strip('#').strip()
        project['line_number'] = line_number_start+1
        project['children'] = lines_into_projects(all_lines, project_lines, depth+1)
        projects.append(project)

    return projects

lines_with_numbers = [ ]
for line_number in range(0, len(projects_text_lines)):
    line = projects_text_lines[line_number]
    lines_with_numbers.append({'text' : line, 'line_number' : line_number})

out['projects'] = lines_into_projects(lines_with_numbers, lines_with_numbers)

print(json.dumps(out, indent=2))


